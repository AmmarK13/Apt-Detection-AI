![[Pasted image 20250406003154.png]]
$python3 1.missingval.py 
Dropped columns: []
/home/kay/Documents/Workspace-S25/SE/SeProject/APT DETECTION/z.after mids progress/processing/1.missingval.py:53: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  df[col].fillna(-999 if df[col].min() >=0 else 999, inplace=True)
Removed constant columns: ['Bwd PSH Flags', 'Fwd URG Flags', 'Bwd URG Flags', 'CWE Flag Count', 'Fwd Avg Bytes/Bulk', 'Fwd Avg Packets/Bulk', 'Fwd Avg Bulk Rate', 'Bwd Avg Bytes/Bulk', 'Bwd Avg Packets/Bulk', 'Bwd Avg Bulk Rate']
✅ All missing values handled successfully
(myenv)

```python
import pandas as pd
import seaborn as sns 
import matplotlib.pyplot as plt
import numpy as np

# Load dataset
file_path = "/home/kay/Documents/Workspace-S25/SE/SeProject/APT DETECTION/z.after mids progress/dataset/Friday-WorkingHours-Afternoon-DDos.pcap_ISCX(final).csv"
df = pd.read_csv(file_path)

# Fix column names
df.columns = df.columns.str.strip()

# ---------------------------
# 1. Data Type Sanitization
# ---------------------------
for col in df.select_dtypes('object').columns:
    try:
        df[col] = pd.to_numeric(df[col], errors='raise')
        print(f"Converted {col} to numeric")
    except:
        pass

# ---------------------------
# 2. Missing Value Analysis
# ---------------------------
missing_values = df.isnull().sum()
missing_percentage = (df.isnull().sum() / len(df)) * 100

# Visualization
fig, ax = plt.subplots(1, 2, figsize=(20,6))
sns.heatmap(df.isnull(), cmap="viridis", cbar=False, ax=ax[0], yticklabels=False)
ax[0].set_title("Before Handling")
missing_percentage[missing_percentage > 0].sort_values().plot(
    kind="barh", ax=ax[1], color="red"
)
ax[1].set_title("Missing Values Distribution")
plt.show()

# ---------------------------
# 3. Strategic NaN Handling
# ---------------------------
# Dynamic threshold
threshold = 40 if len(df) < 100_000 else 20
cols_to_drop = missing_percentage[missing_percentage > threshold].index
df = df.drop(columns=cols_to_drop)
print(f"Dropped columns: {list(cols_to_drop)}")

# Cybersecurity-aware imputation
num_cols = df.select_dtypes(include=np.number).columns
for col in num_cols:
    if df[col].isnull().sum() > 0:
        df[f"{col}_IS_MISSING"] = df[col].isnull().astype(int)
        df[col].fillna(-999 if df[col].min() >=0 else 999, inplace=True)

# Categorical handling
cat_cols = df.select_dtypes(exclude=np.number).columns
for col in cat_cols:
    df[col] = df[col].fillna("MISSING")

# ---------------------------
# 4. Post-Cleaning Validation
# ---------------------------
# Remove constant columns
constant_cols = df.columns[df.nunique() == 1]
df = df.drop(columns=constant_cols)
print(f"Removed constant columns: {list(constant_cols)}")

# Final check
if df.isnull().sum().sum() > 0:
    raise ValueError("Critical Error: NaN values still exist after processing!")
else:
    print("✅ All missing values handled successfully")

# Visualization
plt.figure(figsize=(12,6))
sns.heatmap(df.isnull(), cmap="viridis", cbar=False, yticklabels=False)
plt.title("Missing Values After Final Handling")
plt.show()
```
